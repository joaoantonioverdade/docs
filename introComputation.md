## Theory of computation to revive my university days knowledge 

Resume of Sipser - Introduction to the theory of computation

-

There are three traditionally central areas of the theory of computation: 

* **automata**, deals with the definitions and properties of mathematical models of computation.
* **computability**, certain basic problems cannot be solved by computers. As for example the determination of a mathematical statement has true or false. The theory objective is to classify problems as solvable or not.
* **complexity**, *What makes some problems computationally hard and others easy?* we don't know the answer to it, but researchers have discovered an elegant scheme for classifying problems according to their computational difficulty.

-


### Chapter 1 - Regular Languages

A computational model is a idealized computer, accurate in some ways but not in others.

The simplest model is the **finite state machine** or **finite automata**

A finite automata is a model with finite states and inputs. For example a automatic door with two states: open and closed, with two inputs (some pads in the rear and front of the door) that reflect four possible inputs: front, read, both, none. Depending on the input the model jumps from one state to another: 


![State diagram](https://raw.githubusercontent.com/joaoantonioverdade/docs/master/resources/State_diagram_for_automatic_door.png)


The probabilistic counterpart are the **markov chains**.

A language is called a **regular language** if some finite automaton recognizes it.

In the theory of computation the objects are languages and the tools include operations specifically designed for manipulating them. The **regular operations** are three of them (A={good, bad}; B={boy, girl}):

* Union A U B, {good, bad, boy, girl}
* Concatenation A o B, {goodboy, goodgirl, badboy, badgirl}
* Star A*, {E, good, bad, goodgood, goodbad, badgood, goodbadbad, ...}


In a **nondeterministic** machine after a given input we don't know in which will be the next state.  

* DFA, deterministic finite automaton
* NFA, nondeterministic finite automaton (when the same input has two possible states, both *branches* are followed:

![NFA example](https://raw.githubusercontent.com/joaoantonioverdade/docs/master/resources/NFA%20example.png)

Every nondeterministic finite automaton has an equivalent deterministic finite automaton.

**Regular expressions** are build up expressions describing languages, originated from regular operations, ex.: (0 U 1)*

Regular expressions and finite automata are equivalent in their descriptive power. Any regular expression can be converted into a finite automaton that recognizes the language it describes and vice versa.

Certain languages cannot be recognized by any finite automaton, ex.: L={0^n 1^n | n >=0 }, a finite automaton needs a finite number of states, which in the language L isn't limited.

Common examples of non-regular languages are the HTML or XML, where regular expressions fail to parse them.


### Chapter 2 - Context-free Languages

**Context-free grammars** are a a more powerful method than regular expressions or finite automata for describing languages, allowing a recursive structure.

Example of grammar:

A -> 0A1

A -> B

B -> #


Sometimes a grammar can generate the same string in several different ways. Such a string will have several different parse trees and thus several different meanings. If a grammar generates the same string in several different ways, we say that the string is derived **ambiguously** in that grammar.


When working with context-free grammars, it is often convenient to have them in simplified form. One of the simplest and most useful forms is called the Chomsky normal form. Chomsky normal form is useful in giving algorithms for working with context-free grammars. Any context-free language is generated by a context-free grammar in Chomsky normal form.


**Pushdown automata** (PDA) is a computational model like nondeterministic finite automat but with an extra component called a stack. A stack provides additional memory beyond the finite amount available in the control, allowing to recognize some nonregular languages. They are equivalent in power to the context-free grammars.

A stack can hold an unlimited amount of information. For the non regular language L=0^n 1^n | n>=0 the following informal description shows how the pushdown automaton works:

Read symbols from the input. As each 0 is read, push it onto the stack. As soon as 1s are seen, pop a 0 off the stack for each 1 read. If reading the input is finished exactly when the stack becomes empty of 0s, accpet the input. If the stack becomes empty while 1s remain or if the 1s are finished while the stack still contains 0s or if any 0s appear in the input following 1s, reject the input.


### Chapter 3 - Turing Machines

Similar to a finite automaton but with an unlimited and unrestricted memory, a **Turing machine** is a much accurate model of a general purpose computer. A Turing machine can do everything that a real computer can do. Nonetheless, even a Turing machine cannot solve certain problems. In a very real sense, these problems are beyond the theoretical limits of computation.


The Turing machine model uses an infinite tape as its unlimited memory. It has a tape head that can read and write symbols and move around on the tape. Initially the tape contains only the input string and is blank everywhere eles. If the machine needs to store information, it may write this information on the tape. To read the information that it has written, the machine can move its head back over it. The machine continues computing until it decides to produce an output. The outputs *accept* and *reject* are obtained by entering designated accepting and rejecting states. If it doesn't enter an accepting or a rejecting state, it will go on forever, never halting.

The differences between finite automata and Turing machines:
* A turing machine can both write on the tape and read from it
* The read-write head can move both to the left and to the right
* The tape is infinite
* The special states for rejecting and accepting take effect immediately






